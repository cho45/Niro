.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DateTime::Format::SQLite 3"
.TH DateTime::Format::SQLite 3 "2009-12-11" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
DateTime::Format::SQLite \- Parse and format SQLite dates and times
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DateTime::Format::SQLite;
.Ve
.PP
.Vb 1
\&  my $dt = DateTime::Format::SQLite\->parse_datetime( \(aq2003\-01\-16 23:12:01\(aq );
.Ve
.PP
.Vb 2
\&  # 2003\-01\-16 23:12:01
\&  DateTime::Format::SQLite\->format_datetime($dt);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module understands the formats used by SQLite for its
\&\f(CW\*(C`date\*(C'\fR, \f(CW\*(C`datetime\*(C'\fR and \f(CW\*(C`time\*(C'\fR functions.  It can be used to
parse these formats in order to create DateTime objects, and it
can take a DateTime object and produce a timestring accepted by
SQLite.
.PP
\&\fB\s-1NOTE:\s0\fR SQLite does not have real date/time types but stores
everything as strings. This module deals with the date/time
strings as understood/returned by SQLite's \f(CW\*(C`date\*(C'\fR, \f(CW\*(C`time\*(C'\fR,
\&\f(CW\*(C`datetime\*(C'\fR, \f(CW\*(C`julianday\*(C'\fR and \f(CW\*(C`strftime\*(C'\fR \s-1SQL\s0 functions.
You will usually want to store your dates in one of these formats.
.SH "METHODS"
.IX Header "METHODS"
This class offers the methods listed below.  All of the parsing
methods set the returned DateTime object's time zone to the \fB\s-1UTC\s0\fR
zone because SQLite does always uses \s-1UTC\s0 for date calculations.
This means your dates may seem to be one day off if you convert
them to local time.
.IP "* parse_datetime($string)" 4
.IX Item "parse_datetime($string)"
Given a \f(CW$string\fR representing a date, this method will return a new
\&\f(CW\*(C`DateTime\*(C'\fR object.
.Sp
The \f(CW$string\fR may be in any of the formats understood by SQLite's
\&\f(CW\*(C`date\*(C'\fR, \f(CW\*(C`time\*(C'\fR, \f(CW\*(C`datetime\*(C'\fR, \f(CW\*(C`julianday\*(C'\fR and \f(CW\*(C`strftime\*(C'\fR \s-1SQL\s0
functions or it may be in the format returned by these functions
(except \f(CW\*(C`strftime\*(C'\fR, of course).
.Sp
The time zone for this object will always be in \s-1UTC\s0 because SQLite
assumes \s-1UTC\s0 for all date calculations.
.Sp
If \f(CW$string\fR contains no date, the parser assumes 2000\-01\-01
(just like SQLite).
.Sp
If given an improperly formatted string, this method may die.
.IP "* parse_date($string)" 4
.IX Item "parse_date($string)"
.PD 0
.IP "* parse_time($string)" 4
.IX Item "parse_time($string)"
.IP "* parse_julianday($string)" 4
.IX Item "parse_julianday($string)"
.PD
These are aliases for \f(CW\*(C`parse_datetime\*(C'\fR, for symmetry with
\&\f(CW\*(C`format_\f(CI*\f(CW\*(C'\fR functions.
.IP "* format_date($datetime)" 4
.IX Item "format_date($datetime)"
Given a \f(CW\*(C`DateTime\*(C'\fR object, this methods returnes a string in the
format \s-1YYYY\-MM\-DD\s0, i.e. in the same format SQLite's \f(CW\*(C`date\*(C'\fR
function uses.
.IP "* format_time($datetime)" 4
.IX Item "format_time($datetime)"
Given a \f(CW\*(C`DateTime\*(C'\fR object, this methods returnes a string in the
format \s-1HH:MM:SS\s0, i.e. in the same format SQLite's \f(CW\*(C`time\*(C'\fR
function uses.
.IP "* format_datetime($datetime)" 4
.IX Item "format_datetime($datetime)"
Given a \f(CW\*(C`DateTime\*(C'\fR object, this methods returnes a string in the
format YYYY-MM-DD \s-1HH:MM:SS\s0, i.e. in the same format SQLite's \f(CW\*(C`datetime\*(C'\fR
function uses.
.IP "* format_julianday($datetime)" 4
.IX Item "format_julianday($datetime)"
Given a \f(CW\*(C`DateTime\*(C'\fR object, this methods returnes a string in the
format \s-1DDDDDDDDDD\s0, i.e. in the same format SQLite's \f(CW\*(C`julianday\*(C'\fR
function uses.
.SH "AUTHOR"
.IX Header "AUTHOR"
Claus Färber <CFAERBER@cpan.org>
.PP
based on \f(CW\*(C`DateTime::Format::MySQL\*(C'\fR by David Rolsky.
.SH ""
.IX Header ""
Copyright © 2008 Claus Färber.
.PP
Copyright © 2003 David Rolsky. 
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the \s-1LICENSE\s0 file
included with this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
http://datetime.perl.org/
.PP
http://www.sqlite.org/lang_datefunc.html
